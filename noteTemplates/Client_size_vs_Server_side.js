const initialText = 
'# Client-side vs. Server-side\n---------------\n\nThere is something going on within the front-end community recently. Server-side rendering is getting more and more traction thanks to React and its built-in server-side hydration feature. But it’s not the only solution to deliver a fast experience to the user with a super fast time-to-first-byte (TTFB) score: Pre-rendering is also a pretty good strategy. What’s the difference between these solutions and a fully client-rendered application?\n\n## Client-rendered Application\n\nSince frameworks like Angular, Ember.js, and Backbone exists, front-end developers have tended to render everything client-side. Thanks to Google and its ability to “read” JavaScript, it works pretty well, and it’s even SEO friendly.\n\nWith a client-side rendering solution, you redirect the request to a single HTML file and the server will deliver it without any content (or with a loading screen) until you fetch all the JavaScript and let the browser compile everything before rendering the content.\n\nUnder a good and reliable internet connection, it’s pretty fast and works well. But it can be a lot better, and it doesn’t have to be difficult to make it that way. That’s what we will see in the following sections.\n\n## Server-side Rendering (SSR)\n\nAn SSR solution is something we used to do a lot, many years ago, but tend to forget in favor of a client-side rendering solution.\n\nWith old server-side rendering solutions, you built a web page—with PHP for example—the server compiled everything, included the data, and delivered a fully populated HTML page to the client. It was fast and effective.\n\nBut… every time you navigated to another route, the server had to do the work all over again: Get the PHP file, compile it, and deliver the HTML, with all the CSS and JS delaying the page load to a few hundred ms or even whole seconds.\n\n**What if you could do the first page load with the SSR solution, and then use a framework to do dynamic routing with AJAX, fetching only the necessary data?**\n\nThis is why SSR is getting more and more traction within the community because React popularized this problem with an easy-to-use solution: The RenderToString method.\n\nThis new kind of web application is called a universal app or an isomorphic app. There’s still some controversy over the exact meanings of these terms and the relationship between them, but many people use them interchangeably.\n\nAnyway, the advantage of this solution is being able to develop an app server-side and client-side with the same code and deliver a really fast experience to the user with custom data. The disadvantage is that you need to run a server.\n\nSSR is used to fetch data and pre-populate a page with custom content, leveraging the server’s reliable internet connection. That is, the server’s own internet connection is better than that of a user with lie-fi), so it’s able to prefetch and amalgamate data before delivering it to the user.\n\nWith the pre-populated data, using an SSR app can also fix an issue that client-rendered apps have with social sharing and the OpenGraph system. For example, if you have only one index.html file to deliver to the client, they will only have one type of metadata—most likely your homepage metadata. This won’t be contextualized when you want to share a different route, so none of your routes will be shown on other sites with their proper user content (description and preview picture) that users would want to share with the world.\n\n## Pre-rendering\n\nThe mandatory server for a universal app can be a deterrent for some and may be overkill for a small application. This is why pre-rendering can be a really nice alternative.\n\nI discovered this solution with Preact and its own CLI that allows you to compile all pre-selected routes so you can store a fully populated HTML file to a static server. This lets you deliver a super-fast experience to the user, thanks to the Preact/React hydration function, without the need for Node.js.\n\nThe catch is, because this isn’t SSR, you don’t have user-specific data to show at this point—it’s just a static (and somewhat generic) file sent directly on the first request, as-is. So if you have user-specific data, here is where you can integrate a beautifully designed skeleton to show the user their data is coming, to avoid some frustration on their part:\n\n![alt text](https://uploads.toptal.io/blog/image/127004/toptal-blog-image-1535620212839-b5688b29b5058b9c9cf251284e7d0779.png)\n\n**There is another catch: In order for this technique to work, you still need to have a proxy or something to redirect the user to the right file.**\n\n## Why?\n\nWith a single-page application, you need to redirect all requests to the root file, and then the framework redirects the user with its built-in routing system. So the first page load is always the same root file.\n\nIn order for a pre-rendering solution to work, you need to tell your proxy that some routes need specific files and not always the root index.html file.\n\nFor example, say you have four routes (/, /about, /jobs, and blog) and all of them have different layouts. You need four different HTML files to deliver the skeleton to the user that will then let React/Preact/etc. rehydrate it with data. So if you redirect all those routes to the root index.html file, the page will have an unpleasant, glitchy feel during loading, whereby the user will see the skeleton of the wrong page until it finishes loading and replaces the layout. For example, the user might see a homepage skeleton with only one column, when they had asked for a different page with a Pinterest-like gallery.\n\nThe solution is to tell your proxy that each of those four routes needs a specific file:\n\nhttps://my-website.com → Redirect to the root index.html file\n\nhttps://my-website.com/about → Redirect to the /about/index.html file\n\nhttps://my-website.com/jobs → Redirect to the /jobs/index.html file\n\nhttps://my-website.com/blog → Redirect to the /blog/index.html file\n\nThis is why this solution can be useful for small applications—you can see how painful it would be if you had a few hundred pages.\n\nStrictly speaking, it’s not mandatory to do it this way—you could just use a static file directly. For example, https://my-website.com/about/ will work without any redirection because it will automatically search for an index.html inside its directory. But you need this proxy if you have param urls—https://my-website.com/profile/guillaume will need to redirect the request to /profile/index.html with its own layout, because profile/guillaume/index.html doesn’t exist and will trigger a 404 error.\n\n\n![alt text](https://uploads.toptal.io/blog/image/127005/toptal-blog-image-1535714166711-83ff57e99f24e7b39e79cc0c766015ac.png)\n\nIn short, there are three basic views at play with the rendering strategies described above: A loading screen, a skeleton, and the full page once it’s finally rendered.\n\n\n![alt text](https://uploads.toptal.io/blog/image/126998/toptal-blog-image-1535533781994-120b5191e09b6abe2e0cae668ffbe5d8.png)\n\n## Client-only Rendering is Often Not Enough\n\nClient-rendered applications are something we should avoid now because we can do better for the user. And doing better, in this case, is as easy as the pre-rendering solution. It’s definitely an improvement over client-only rendering and easier to implement than a fully server-side-rendered application.\n\nAn SSR/universal application can be really powerful if you have a large application with a lot of different pages. It allows your content to be focused and relevant when talking to a social crawler. This is also true for search engine robots, which now take your site’s performance into account when ranking it.\n\nStay tuned for a follow-up tutorial, where I will walk through the transformation of an SPA into pre-rendered and SSR versions, and compare their performance.'
export default initialText;